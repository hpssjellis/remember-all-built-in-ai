<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spaced Repetition Timeline with Adaptive Factors</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Vis.js Timeline Assets -->
  <script src="https://unpkg.com/vis-timeline@7.7.1/standalone/umd/vis-timeline-graph2d.min.js"></script>
  <link
    href="https://unpkg.com/vis-timeline@7.7.1/styles/vis-timeline-graph2d.min.css"
    rel="stylesheet"
    type="text/css"
  />
  <!-- Minimal inline CSS for basic layout/functionality -->
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #timeline {
      width: 95%;
      height: 300px; /* Default height */
      border: 1px solid #ccc;
      margin-top: 20px;
    }

    #myCustomTooltip {
      position: absolute;
      display: none;
      max-width: 600px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 6px;
      z-index: 1000;
      white-space: normal;
      pointer-events: none;
      font-size: 14px;
    }

    .factor-box {
        display: flex;
        gap: 20px;
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
  </style>
</head>

<body>

  <!-- TIMELINE SECTION -->
  <h2>Vis.js Timeline: Spaced Repetition</h2>
  
  <!-- Entry Form -->
  <div style="margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; max-width: 600px;">
    <h3>Add/Edit Item</h3>
    <label for="myEntryId" style="display: inline-block; width: 50px;">ID:</label>
    <input type="number" id="myEntryId" readonly style="width: 60px; margin-right: 20px;" />
    <label for="myEntryDate" style="display: inline-block; width: 50px;">Date:</label>
    <input type="datetime-local" id="myEntryDate" style="width: 220px; margin-right: 20px;" /><br /><br />

    <label for="myEntryContent" style="display: block; font-weight: bold;">Content (Hint):</label>
    <input type="text" id="myEntryContent" style="width: 100%; margin-bottom: 10px;" placeholder="Enter content" />

    <label for="myEntryLongDescription" style="display: block; font-weight: bold;">Long Description (Answer):</label>
    <textarea id="myEntryLongDescription" rows="4" style="width: 100%; margin-bottom: 10px;" placeholder="Enter long description/correct answer"></textarea>

    <button id="myNextEntryButton" style="margin-right: 10px;" onclick="myAutofillNextEntry()">Next Entry (Clear)</button>
    <button id="myAddEntryButton" onclick="myAddEntry(); myPopulateSelectBox();">Add / Update</button>
  </div>
  
  <!-- Height Controls -->
  <div style="margin-bottom: 10px;">
      <button onclick="mySetTimelineHeight(150)">Small Height (150px)</button>
      <button onclick="mySetTimelineHeight(300)">Medium Height (300px)</button>
      <button onclick="mySetTimelineHeight(600)">Large Height (600px)</button>
  </div>

  <div id="timeline"></div>
  <div id="myCustomTooltip"></div>

  <!-- --- -->

  <!-- CHROME AI TOOL SECTION -->
  <hr style="margin: 40px 0;">
  <div style="font-family: sans-serif; max-width: 800px; margin: auto; padding: 20px;">
    <h1>Chrome Built-in AI: Statement Comparison Tool</h1>
    <div class="factor-box" id="myFactorDisplay">
        <!-- Factor values will be displayed here -->
    </div>
    <div style="margin-top: 20px;">
      <h2>Test Your Memory</h2>
        
      <!-- Select Box -->
      <p>Items due for review (Start Date $\le$ Now):</p>
      <select id="myQuestionSelectBox" size="1" onchange="myLoadQuestion(this.value);" style="margin-bottom: 10px; width: 100%;">
        <!-- Options will be populated dynamically -->
      </select><br>

      Question Hint: <input type="text" id="myHintInput" readonly style="width: 100%; margin-bottom: 10px;"> <br>
      <input type="hidden" id="myPresentNumber"> <!-- Hidden ID for the selected item -->
        
      <!-- Stored statement -->
      <label for="myStoredStatement">Stored Answer (Should be hidden during test):</label>
      <textarea id="myStoredStatement" rows="3" placeholder="Stored Answer" readonly style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-top: 5px;"></textarea>
        
      <label for="myUserTest">Your Recall/Answer:</label>
      <textarea id="myUserTest" rows="3" placeholder="Enter your remembered statement..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; margin-top: 5px;"></textarea>

      <button id="myCheckButton" onclick="myCheckSimilarity()" style="display: block; width: 100%; padding: 10px; margin-top: 10px; font-size: 16px; color: white; background-color: #4CAF50; border: none; border-radius: 5px; cursor: pointer;">Check Similarity & Update Schedule</button>
    </div>

    <div style="margin-top: 20px;">
      <h2>Status and Output</h2>
      <p id="myStatus" style="font-style: italic; color: #555;">Ready. Select an item and enter your answer.</p>
      <textarea id="myOutput" rows="3" readonly style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background-color: #eee; box-sizing: border-box; margin-top: 10px;"></textarea>
    </div>
  </div>

  <!-- --- -->
  
  <!-- COMBINED SCRIPTS -->
  <script>
    // --- Global Variables & Factors ---
    const myContainer = document.getElementById('timeline');
    const myTooltip = document.getElementById('myCustomTooltip');
    const myQuestionSelectBox = document.getElementById('myQuestionSelectBox');
    
    // Spaced Repetition Learning Factors (using simple objects to allow pass-by-reference updates)
    const myLearn = { value: 1.50 }; // Multiplier for correct answer interval
    const myForget = { value: 1.50 }; // Divisor for incorrect answer penalty
    const myAdjustmentRate = 0.05; 
    const ONE_DAY_MS = 24 * 60 * 60 * 1000;
    
    // Timeline Data Storage
    const myItemsDataSet = new vis.DataSet([
      {
        id: 1,
        content: 'Cookie Ingredients',
        start: '2025-09-29T00:00:00.000Z', // Next review date (due)
        longDescription: 'chocolat, butter, granola, peanut butter, cooked', // Stored Answer
        myOriginalStart: '2025-07-26T10:00:00.000Z', // Original creation date (NEVER CHANGES)
        myCorrectCount: 0, // Number of times recalled correctly
      },
      {
        id: 2,
        content: 'DNA Acronym',
        start: '2025-09-30T14:00:00.000Z', // Not due yet
        longDescription: 'Deoxyribonucleic acid',
        myOriginalStart: '2025-05-27T14:00:00.000Z',
        myCorrectCount: 0,
      },
      {
        id: 3,
        content: '3+7',
        start: '2025-09-28T09:00:00.000Z', // Due
        longDescription: '10',
        myOriginalStart: '2025-01-28T09:00:00.000Z',
        myCorrectCount: 0,
      },
    ]);

    // Vis.js Timeline Setup
    const myTimeline = new vis.Timeline(myContainer, myItemsDataSet, {
      type: 'box',
      tooltip: {
        followMouse: false,
      },
      // Ensure the timeline updates its internal rendering when the container size changes
      autoResize: true, 
    });

    // --- Factor Display UI ---
    function myUpdateFactorDisplay() {
        const myDisplay = document.getElementById('myFactorDisplay');
        myDisplay.innerHTML = `
            <div>
                <strong>myLearn Factor:</strong> 
                <span style="color: green; font-weight: bold;">${myLearn.value.toFixed(2)}</span> 
                (Success Multiplier)
            </div>
            <div>
                <strong>myForget Factor:</strong> 
                <span style="color: red; font-weight: bold;">${myForget.value.toFixed(2)}</span> 
                (Failure Divisor)
            </div>
        `;
    }
    
    myUpdateFactorDisplay(); // Initial display
    
    // --- Timeline Height Resizing Function (Method 2) ---

    function mySetTimelineHeight(myNewHeight) {
      // 1. Update the CSS height of the container element
      myContainer.style.height = myNewHeight + 'px'; 

      // 2. Explicitly tell the Vis.js object to adopt the new height
      myTimeline.setOptions({ 
          height: myNewHeight + 'px' 
      }); 
    }

    // --- Timeline Interaction Logic ---
    
    // Mouseover: Shows basic info (Hint, Original Date, Correct Count)
    myTimeline.on('itemover', function (props) {
      const myItem = myItemsDataSet.get(props.item);
      if (myItem) {
        const myOriginalTime = new Date(myItem.myOriginalStart).toLocaleDateString();
        myTooltip.innerHTML = 
          `**Hint:** ${myItem.content}<br>` + 
          `**Original Date:** ${myOriginalTime}<br>` +
          `**Correct Count:** ${myItem.myCorrectCount}`;
        myTooltip.style.display = 'block';
      }
    });

    myTimeline.on('itemout', function () {
      myTooltip.style.display = 'none';
    });

    myContainer.addEventListener('mousemove', function (myEvent) {
      myTooltip.style.left = myEvent.pageX + 10 + 'px';
      myTooltip.style.top = myEvent.pageY + 10 + 'px';
    });

    // Double Click: Shows the full answer (Long Description)
    myTimeline.on('doubleClick', function (props) {
      const myItem = myItemsDataSet.get(props.item);
      if (myItem && myItem.longDescription) {
        myTooltip.innerHTML = `**ANSWER:**<br>${myItem.longDescription.replace(/\n/g, '<br>')}`;
        myTooltip.style.display = 'block';
        // Hide the tooltip after 3 seconds
        setTimeout(() => {
          myTooltip.style.display = 'none';
        }, 3000);
      }
    });
    
    // Click: Loads item data into the entry form for editing
    myTimeline.on('click', function (props) {
      if (props.item !== null) {
          myLoadItemForEdit(props.item);
      }
    });

    // --- Entry Form / Data Management Functions ---
    const myEntryIdInput = document.getElementById('myEntryId');
    const myEntryDateInput = document.getElementById('myEntryDate');
    const myEntryContentInput = document.getElementById('myEntryContent');
    const myEntryLongDescriptionInput = document.getElementById('myEntryLongDescription');
    
    // Loads an item's data into the entry form for editing
    function myLoadItemForEdit(myId) {
        const myItem = myItemsDataSet.get(parseInt(myId));
        if (myItem) {
            myEntryIdInput.value = myItem.id;
            // Convert ISO start date back to local datetime format for input field
            myEntryDateInput.value = myIsoToLocalDateTime(myItem.start); 
            myEntryContentInput.value = myItem.content;
            myEntryLongDescriptionInput.value = myItem.longDescription;
        }
    }

    function myGetNextId() {
      const myAllIds = myItemsDataSet.getIds();
      return myAllIds.length ? Math.max(...myAllIds) + 1 : 1;
    }

    function myGetCurrentDateTimeLocal() {
      const now = new Date();
      now.setSeconds(0, 0);
      const myOffset = now.getTimezoneOffset();
      // Adjust to local time string format for datetime-local input
      const myLocalDate = new Date(now.getTime() - myOffset * 60000); 
      return myLocalDate.toISOString().slice(0, 16);
    }

    function myAutofillNextEntry() {
      myEntryIdInput.value = myGetNextId();
      myEntryDateInput.value = myGetCurrentDateTimeLocal();
      myEntryContentInput.value = '';
      myEntryLongDescriptionInput.value = '';
    }

    function myAddEntry() {
      const myId = Number(myEntryIdInput.value);
      const myContent = myEntryContentInput.value.trim();
      const myLongDescription = myEntryLongDescriptionInput.value.trim();
      const myDateTimeLocal = myEntryDateInput.value;

      if (!myContent || !myLongDescription) {
        alert('Please enter both Content (Hint) and Long Description (Answer).');
        return;
      }
      if (!myDateTimeLocal) {
        alert('Please enter a valid date and time.');
        return;
      }

      const myIsoString = new Date(myDateTimeLocal).toISOString();
      const myExistingItem = myItemsDataSet.get(myId);

      if (myExistingItem) {
        // --- UPDATE EXISTING ITEM ---
        myExistingItem.content = myContent;
        myExistingItem.longDescription = myLongDescription;
        myExistingItem.start = myIsoString; // Allows editing the next review date
        myItemsDataSet.update(myExistingItem);
        alert(`Item ${myId} updated!`);
      } else {
        // --- ADD NEW ITEM ---
        myItemsDataSet.add({
          id: myId,
          content: myContent,
          start: myIsoString,
          longDescription: myLongDescription,
          myOriginalStart: myIsoString, // Set the fixed original date
          myCorrectCount: 0, 
        });
        alert(`New Item ${myId} added!`);
      }


      myAutofillNextEntry();
    }

    myAutofillNextEntry();
    
    // --- Select Box / Question Loading Functions ---

    // Populate the select box only with items whose 'start' date is past or present
    function myPopulateSelectBox() {
      const myAllItems = myItemsDataSet.get();
      myQuestionSelectBox.innerHTML = ''; 
      
      const myNow = new Date(); // Get current date/time

      // Filter items to only include those whose 'start' date is <= myNow
      const myDueItems = myAllItems.filter(myItem => new Date(myItem.start) <= myNow);

      const myDefaultOption = document.createElement('option');
      myDefaultOption.textContent = myDueItems.length > 0 ? 'Select a DUE Question to Test' : 'No items due yet!';
      myDefaultOption.value = '';
      myQuestionSelectBox.appendChild(myDefaultOption);

      if (myDueItems.length === 0) {
        myLoadQuestion(null); // Clear testing area
        return;
      }

      myDueItems.forEach(myItem => {
        const myOption = document.createElement('option');
        myOption.value = myItem.id;
        myOption.textContent = `#${myItem.id} - ${myItem.content}`;
        myQuestionSelectBox.appendChild(myOption);
      });
      
      // Load the first due item automatically
      if (myDueItems.length > 0) {
          myQuestionSelectBox.value = myDueItems[0].id;
          myLoadQuestion(myDueItems[0].id);
      }
    }

    // Load selected item's data into the testing area
    function myLoadQuestion(myId) {
      if (!myId) {
          document.getElementById('myStoredStatement').value = '';
          document.getElementById('myHintInput').value = '';
          document.getElementById('myUserTest').value = '';
          document.getElementById('myPresentNumber').value = '';
          return;
      }
      
      const myItem = myItemsDataSet.get(parseInt(myId)); 
      
      if (myItem) {
        document.getElementById('myStoredStatement').value = myItem.longDescription || '';
        document.getElementById('myHintInput').value = myItem.content || '';
        document.getElementById('myUserTest').value = '';
        document.getElementById('myPresentNumber').value = myId;
      } else {
        console.warn('Item not found with ID:', myId);
      }
    }

    // Initial population
    myPopulateSelectBox();
    
    // --- Date Utility Functions ---

    function myIsoToMillis(myIsoString) {
      return new Date(myIsoString).getTime();
    }
    
    function myMillisToIso(myMillis) {
      return new Date(myMillis).toISOString();
    }
    
    function myIsoToLocalDateTime(myIsoString) {
      const myDate = new Date(myIsoString);
      const myOffset = myDate.getTimezoneOffset() * 60000; 
      const myLocalTime = new Date(myDate.getTime() - myOffset);
      return myLocalTime.toISOString().slice(0, 16);
    }
    
    // --- LLM Status / Timer Functions ---
    
    let myLanguageModelSession = null;
    let myTimerInterval = null;
    const myStatus = document.getElementById('myStatus');
    const myOutput = document.getElementById('myOutput');
    const myCheckButton = document.getElementById('myCheckButton');

    function myStartTimer() {
      let mySeconds = 0;
      myStatus.textContent = "Working... 0s";
      myTimerInterval = setInterval(() => {
        mySeconds++;
        myStatus.textContent = `Working... ${mySeconds}s`;
      }, 1000);
    }

    function myStopTimer(myMessage) {
      if (myTimerInterval) {
        clearInterval(myTimerInterval);
        myTimerInterval = null;
      }
      myStatus.textContent = myMessage;
    }

    // --- LLM & Spaced Repetition Logic ---

    // Update the next review date and adjust myLearn/myForget factors
    function myUpdateMemory(myQuestionId, myLastScheduledReviewTimeIso, myIsCorrect) {
        
        const myItemToUpdate = myItemsDataSet.get(parseInt(myQuestionId));
        if (!myItemToUpdate) {
            console.error('Item not found for update:', myQuestionId);
            return;
        }

        const myNow = Date.now();
        const myLastScheduledReviewTime = myIsoToMillis(myLastScheduledReviewTimeIso); 
        
        // Time difference: Positive means overdue (tested late), Negative means early (tested before schedule)
        const myTimeDifference = myNow - myLastScheduledReviewTime; 
        
        // This is the duration of the *previous* successful interval (or time since original creation if myCorrectCount is 0)
        // We use the time difference from the scheduled time to now as the basis for the next interval
        const myDuration = Math.max(myTimeDifference, ONE_DAY_MS); // Ensure we use a positive duration
        
        let myNextDateTime;
        let myMessage;
        let myAdjustmentMessage = '';
        
        const myMaxFactor = 3.0; // Max ceiling for factors
        const myMinFactor = 1.1; // Min floor for factors (must be > 1)

        if (myIsCorrect) {
            // --- SUCCESSFUL TEST LOGIC ---
            
            // 1. Calculate the next interval based on the current myLearn factor
            const myNewInterval = myDuration * myLearn.value;
            myNextDateTime = myNow + myNewInterval;
            myItemToUpdate.myCorrectCount++; 
            myMessage = `schedule updated! Correct count: ${myItemToUpdate.myCorrectCount}.`;
            
            // 2. Adjust myLearn factor based on how late the user was
            if (myTimeDifference > ONE_DAY_MS * 2) { 
                // Tested > 2 days late and succeeded: myLearn was too low
                myLearn.value = Math.min(myLearn.value + myAdjustmentRate, myMaxFactor);
                myAdjustmentMessage = 'myLearn factor increased (tested very late & correct).';
            } else if (myTimeDifference < -ONE_DAY_MS * 0.5) {
                // Tested > 12 hours early and succeeded: myLearn might be too high (being conservative)
                myLearn.value = Math.max(myLearn.value - (myAdjustmentRate / 2), myMinFactor);
                myAdjustmentMessage = 'myLearn factor slightly decreased (tested early & correct).';
            } else {
                myAdjustmentMessage = 'myLearn factor stable.';
            }

        } else {
            // --- FAILED TEST LOGIC ---
            
            // 1. Calculate the penalty interval based on the current myForget factor
            const myEffectiveDuration = Math.max(myDuration, 60000); // Use min 1 minute penalty 
            const myNewInterval = myEffectiveDuration / myForget.value; 
            myNextDateTime = myNow + myNewInterval;
            myMessage = `schedule penalized!`;
            myItemToUpdate.myCorrectCount = 0; // Reset correct count on failure

            // 2. Adjust myForget factor based on when the failure occurred
            const myAbsoluteTimeDiff = Math.abs(myTimeDifference);

            if (myAbsoluteTimeDiff < ONE_DAY_MS) {
                // Failed right around the scheduled time (+/- 1 day): myForget needs to be harsher
                myForget.value = Math.min(myForget.value + myAdjustmentRate, myMaxFactor); 
                myAdjustmentMessage = 'myForget factor increased (failed on time).';
            } else if (myTimeDifference > ONE_DAY_MS * 3) {
                // Failed way late (> 3 days): penalty was already significant due to time, so myForget is slightly eased
                myForget.value = Math.max(myForget.value - (myAdjustmentRate / 2), myMinFactor); 
                myAdjustmentMessage = 'myForget factor slightly decreased (failed very late).';
            } else {
                myAdjustmentMessage = 'myForget factor stable.';
            }
        }
        
        const myNewIsoStart = myMillisToIso(myNextDateTime);
        myItemToUpdate.start = myNewIsoStart; 
        
        myItemsDataSet.update(myItemToUpdate);
        myUpdateFactorDisplay(); // Update the displayed factors
        
        myStatus.textContent += ` Item #${myQuestionId} ${myMessage} ${myAdjustmentMessage} Next review: ${new Date(myNextDateTime).toLocaleString()}.`;
    }

    async function myCheckSimilarity() {
      const myStoredStatement = document.getElementById('myStoredStatement');
      const myUserTest = document.getElementById('myUserTest');
      const myPresentNumberInput = document.getElementById('myPresentNumber');
      
      const myQuestionId = myPresentNumberInput.value;
      if (!myQuestionId) {
          myStopTimer('Please select an item to test first.');
          return;
      }
      
      const myItem = myItemsDataSet.get(parseInt(myQuestionId));
      if (!myItem) {
          myStopTimer('Error: Selected item not found.');
          return;
      }

      myCheckButton.disabled = true;
      myCheckButton.style.backgroundColor = '#ccc';
      myOutput.value = "";

      try {
        if (!('LanguageModel' in window)) {
          myStopTimer("Error: LanguageModel API not available. Check Chrome flags.");
          return;
        }

        myStartTimer();

        if (!myLanguageModelSession) {
          myStatus.textContent = 'Creating AI session...';
          myLanguageModelSession = await LanguageModel.create();
          myStatus.textContent = 'Session created. Sending prompt...';
        }

        const myStoredValue = myStoredStatement.value.trim();
        const myUserValue = myUserTest.value.trim();

        if (!myStoredValue || !myUserValue) {
          myStopTimer('Please fill in both Your Recall/Answer and ensure a question is loaded.');
          return;
        }
        
        const myPrompt = `Compare the meaning of the following two statements and determine if they express the same general idea. Ignore differences in letter casing (e.g., uppercase vs lowercase). Only respond with one word: "same" if they mean the same thing, or "different" if they do not. Do not explain your answer.\nStatement 1: ${myStoredValue}\nStatement 2: ${myUserValue}`;

        const myResponse = await myLanguageModelSession.prompt(myPrompt, {
            outputLanguage: 'en' 
        });
        
        const myResult = myResponse.trim().toLowerCase();
        const myIsSame = myResult === 'same';
        
        myOutput.value = myIsSame ? '✅ Same (Correct)' : '❌ Different (Incorrect)';
        myStopTimer(`Comparison complete! Result: ${myIsSame ? 'Correct' : 'Incorrect'}`);
        
        // --- Spaced Repetition Logic Execution ---
        myUpdateMemory(myQuestionId, myItem.start, myIsSame);

      } catch (myError) {
        myStopTimer("An error occurred. Check the console for details.");
        console.error("Error:", myError);
      } finally {
        myCheckButton.disabled = false;
        myCheckButton.style.backgroundColor = '#4CAF50';
        // Crucial update: Repopulate the select box immediately after a test
        myPopulateSelectBox(); 
      }
    }
  </script>

</body>
</html>
